<!DOCTYPE html>
<meta charset="utf-8">
<body>
<canvas id="example" width="960" height="500"></canvas>
<!--<script src="http://d3js.org/d3.v3.min.js"></script>-->
<script src="d3.min.js"></script>
<script>

var width = 960,
    height = 500;

var canvas = document.querySelector('#example');
var ctx = canvas.getContext('2d');

var sample = poissonDiscSampler(width, height, 10);


function circle(ctx, x, y, R, stroke, fill) {
    ctx.beginPath();
    ctx.moveTo(x + R, y);
    ctx.arc(x, y, R, 0, Math.PI * 2, false);
    ctx.closePath();

    ctx.strokeStyle = stroke || '';
    stroke && ctx.stroke();
    ctx.fillStyle = fill || '';
    fill && ctx.fill();
};






var pts = [];
var s;
var start = new Date().getTime();
console.log('poisson sampler');
while (s = sample()) {
  pts.push(s);
}
console.log('done in ' + (new Date().getTime() - start) + 'ms : ' + pts.length + ' pts');


for (var p = 0; p < pts.length ; p++) {
  circle(ctx, pts[p][0], pts[p][1], 2, null, '#000');
}




// Based on https://www.jasondavies.com/poisson-disc/
function poissonDiscSampler(width, height, radius) {
  var k = 30, // maximum number of samples before rejection
      radius2 = radius * radius,
      R = 3 * radius2,
      cellSize = radius * Math.SQRT1_2,
      gridWidth = Math.ceil(width / cellSize),
      gridHeight = Math.ceil(height / cellSize),
      grid = new Array(gridWidth * gridHeight),
      queue = [],
      queueSize = 0,
      sampleSize = 0,
      attempts=0;

    
  return function() {
    if (!sampleSize) return sample(Math.random() * width, Math.random() * height);

    // Pick a random existing sample and remove it from the queue.
    while (queueSize) {
      var i = Math.random() * queueSize | 0,
          s = queue[i];

      // first check the current sample and see if it neighboring cells have points
      if (!hasRoom(s[0], s[1])) {
        console.log('early');
        queue[i] = queue[--queueSize];
        queue.length = queueSize;
        continue;
      }

      // Make a new candidate between [radius, 2 * radius] from the existing sample.
      for (var j = 0; j < k; ++j) {
        var a = 2 * Math.PI * Math.random(),
            r = Math.sqrt(Math.random() * R + radius2),
            x = s[0] + r * Math.cos(a),
            y = s[1] + r * Math.sin(a);
        attempts++;

        // Reject candidates that are outside the allowed extent,
        // or closer than 2 * radius to any existing sample.
        if (0 <= x && x < width && 0 <= y && y < height && far(x, y)) return sample(x, y);
      }

      queue[i] = queue[--queueSize];
      queue.length = queueSize;
    }
    console.log(` ${sampleSize} samples from ${attempts} attempts, ` + (sampleSize/attempts * 100).toPrecision(2) + '% efficiency');
    return false;
  };


  function far(x, y) {
    var i = x / cellSize | 0,
        j = y / cellSize | 0,
        i0 = Math.max(i - 2, 0),
        j0 = Math.max(j - 2, 0),
        i1 = Math.min(i + 3, gridWidth),
        j1 = Math.min(j + 3, gridHeight);

    for (j = j0; j < j1; ++j) {
      var o = j * gridWidth;
      for (i = i0; i < i1; ++i) {
        if (s = grid[o + i]) {
          var s,
              dx = s[0] - x,
              dy = s[1] - y;
          if (dx * dx + dy * dy < radius2) return false;
        }
      }
    }

    return true;
  }

  function hasRoom(x, y) {
    var i = x / cellSize | 0,
        j = y / cellSize | 0,
        i0 = Math.max(i - 2, 0),
        j0 = Math.max(j - 2, 0),
        i1 = Math.min(i + 3, gridWidth),
        j1 = Math.min(j + 3, gridHeight),
        p;

    var ii = i;
    var jj = j;

    var room = 0;
    var full = 0;

    ctx.globalAlpha = 0.1;

    for (j = j0; j < j1; ++j) {
      var o = j * gridWidth;
      for (i = i0; i < i1; ++i) {
        if (i !== ii && j != jj && grid[o + i]) {
          //console.log('found', grid[o + i]);
          //console.log('check', i, ii, j, jj);
          full++;
          
          //ctx.fillStyle = 'red';
          //ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
          
        } else {
          //ctx.fillStyle = 'green';
          //ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);

          room++;
          //room = true;
          //console.log('nothing in', grid[o + i], o, i);
        }
      }
    }
    //console.log(room, full);
    ctx.globalAlpha = 1;
    return room;
  }


  function sample(x, y) {
    var s = [x, y];
    queue.push(s);
    grid[gridWidth * (y / cellSize | 0) + (x / cellSize | 0)] = s;
    ++sampleSize;
    ++queueSize;
    return s;
  }
}

</script>