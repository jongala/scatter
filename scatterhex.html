<html>
<head>
    <style>
        canvas {
          border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <canvas id="large" width="600" height="600"></canvas>
    <canvas id="small" width="200" height="200"></canvas>
    <script>
    function randomInRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // Generates hexagon center-points for non-overlapping tiling
    function getTiledLayout(w, h, scale) {
        var points = [];
        var hexW = 2 * scale * 0.8660;
        var hexH = scale * 1.5;
        var rows = Math.ceil(h/hexH);
        var cols = Math.ceil(w/hexW);
        var offset;

        for (var row = 0 ; row <= rows ; row++) {
            var r = [];
            for (var col = 0 ; col <= cols ; col++) {
                offset = (row % 2)? (- scale * 0.8660 ) : 0;
                r.push([col * hexW + offset, row * hexH]);
            }
            points.push(r);
        }

        return points;
    }

    function circle(ctx, x, y, R, stroke, fill) {

        ctx.beginPath();
        ctx.moveTo(x + R, y);
        ctx.arc(x, y, R, 0, TWOPI, false);
        if (stroke) {
            ctx.strokeStyle = stroke;
            ctx.stroke();
        }
        if (fill) {
            ctx.fillStyle = fill;
            ctx.fill();
        }

        ctx.closePath();
    };

    function triangle(ctx, p1, p2, p3, fill) {
        if (fill) {
            ctx.fillStyle = fill;
        }
        ctx.beginPath();
        ctx.moveTo(p1[0], p1[1]);
        ctx.lineTo(p2[0], p2[1]);
        ctx.lineTo(p3[0], p3[1]);
        ctx.closePath();
        ctx.fill();
    }

    function isTooClose(p1, p2, d) {
        var dx = p2[0] - p1[0];
        var dy = p2[1] - p1[1];
        return ((dx * dx + dy * dy) < (d * d));
    }

    function avgPoint(p1, p2, p3) {
        return [
            (p1[0] + p2[0] + p3[0])/3,
            (p1[1] + p2[1] + p3[1])/3
         ];
    }

    var floor = Math.floor;
    var TWOPI = Math.PI * 2;


    function scatter(selector, size, pointSize, decorate) {
        var el = document.querySelector(selector);
        var ctx = el.getContext('2d');

        var cellSize = size;
        var R = cellSize / 2;
        var w = el.width;
        var h = el.height;

        var cols = Math.floor(w / cellSize);
        var rows = Math.floor(h / cellSize);

        ctx.fillStyle = 'black';
        ctx.strokeStyle = '#ccc';

        var layout = getTiledLayout(w, h, cellSize);
        var points = [];
        var packed = [];

        if (decorate) {
            ctx.globalCompositeOperation = 'multiply';
        }

        var start = new Date().getTime();
        console.log('start drawing');

        layout.forEach(function(r, row) {
            points.push([]);
            r.forEach(function(p, col) {
                var x = p[0];
                var y = p[1];

                if (decorate) {
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = 0.33;

                    // the area
                    circle(ctx, x, y, cellSize, '#f99', '#fdd');

                    ctx.globalCompositeOperation = 'multiply';
                    circle(ctx, x, y, R, '#f99', '#fff');

                    ctx.globalAlpha = 1;
                }

                // the point
                var a = randomInRange(0, TWOPI);
                var v = randomInRange(0, R - pointSize);
                var px = x + v * Math.cos(a);
                var py = y + v * Math.sin(a);

                points[row].push([px, py]);

                circle(ctx, px, py, pointSize, '#000');

                // show point exclusion zone
                if (decorate) {
                    circle(ctx, px, py, R, '#ace');
                }
            });
        });

        // now pack points in gaps
        var grid = points;
        for (var i = 0 ; i < grid.length - 1 ; i++) {
            var row = grid[i];
            //for (var j = 0; j < row.length - 1 ; j++) {
            for (var j = 0; j < row.length - 1 ; j++) {
                var nextRowColOffset = (i % 2) ? 0 : 1;

                // top triangles
                var p1 = grid[i][j];
                var p2 = grid[i][j + 1];
                var p3 = grid[i + 1][j + nextRowColOffset];


                var packed = avgPoint(p1, p2, p3);
                ctx.globalAlpha = 1;
                if (isTooClose(packed, p1, cellSize) ||
                    isTooClose(packed, p2, cellSize) ||
                    isTooClose(packed, p3, cellSize)) {
                    decorate && circle(ctx, packed[0], packed[1], pointSize, '#faa');
                    decorate && circle(ctx, packed[0], packed[1], R, '#fdc');
                } else {
                    circle(ctx, packed[0], packed[1], pointSize, '#111');
                    decorate && circle(ctx, packed[0], packed[1], R, '#cf9');
                }



                if (decorate) {
                    ctx.fillStyle = '#ace';
                    ctx.globalAlpha = 0.2;
                    triangle(ctx, p1, p2, p3);
                }


                // bottom triangles

                if ( i % 2 && j === 0) {
                    continue;
                }

                var bottomColOffset = (i % 2) ? -1 : 0 ;

                p2 = grid[i + 1][j + 1 + bottomColOffset];
                p3 = grid[i + 1][j + bottomColOffset];

                if(!p1 || !p2 || !p3) {
                    console.log('no bottom at ', i, j + bottomColOffset, bottomColOffset);
                }

                packed = avgPoint(p1, p2, p3);
                ctx.globalAlpha = 1;
                if (isTooClose(packed, p1, cellSize) ||
                    isTooClose(packed, p2, cellSize) ||
                    isTooClose(packed, p3, cellSize)) {
                    decorate && circle(ctx, packed[0], packed[1], pointSize, '#faa');
                    decorate && circle(ctx, packed[0], packed[1], R, '#fdc');
                } else {
                    circle(ctx, packed[0], packed[1], pointSize, '#111');
                    decorate && circle(ctx, packed[0], packed[1], R, '#cf9');
                }

                if (decorate) {
                    ctx.fillStyle = '#def'; //nextRowColOffset ? '#aec' : '#ffc' ;
                    ctx.globalAlpha = 0.2;
                    triangle(ctx, p1, p2, p3);
                }


            }
        }
        ctx.globalAlpha = 1;

        var pointCount = points.length * points[0].length;

        console.log('Rendered ', pointCount, 'points in', new Date().getTime() - start, 'ms');
    }

    scatter('#large', randomInRange(30, 50), randomInRange(3, 6), true);
    scatter('#small', 15, 0.5);





</script>
</body>
</html>