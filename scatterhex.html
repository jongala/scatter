<html>
<head>
    <style>
        canvas {
          border: 1px solid #ddd;
          display: block;
          clear: both;
        }

        html {
            margin: 0;
            padding: 20px;
        }
        body {
            margin: 0;
            padding: 0;
        }

    </style>
</head>
<body>
    <canvas id="large" width="800" height="400"></canvas>
    <canvas id="small" width="800" height="400"></canvas>
    <canvas id="medium" width="800" height="400"></canvas>
    <script>

    var floor = Math.floor;
    var TWOPI = Math.PI * 2;

    function randomInRange(min, max) {
      return min + Math.random() * (max - min);
    }

    // Generates hexagon center-points for non-overlapping tiling
    function getTiledLayout(w, h, scale) {
        var points = [];
        var hexW = 2 * scale * 0.8660;
        var hexH = scale * 1.5;
        var rows = Math.ceil(h/hexH) + 1;
        var cols = Math.ceil(w/hexW) + 1;
        var count = rows * cols;
        var offset;
        var row;

        for (var i = 0 ; i < count ; i++) {
            row = Math.floor(i / cols);
            offset = (row % 2) ? (- scale * 0.8660 ) : 0;
            points.push([
                i % cols * hexW + offset,
                row * hexH
            ]);
        }

        return points;
    }

    function circle(ctx, x, y, R, stroke, fill) {
        ctx.beginPath();
        ctx.moveTo(x + R, y);
        ctx.arc(x, y, R, 0, TWOPI, false);
        ctx.closePath();

        ctx.strokeStyle = stroke || '';
        stroke && ctx.stroke();
        ctx.fillStyle = fill || '';
        fill && ctx.fill();
    };

    function triangle(ctx, p1, p2, p3, stroke, fill) {
        //return;
        ctx.beginPath();
        ctx.moveTo(p1[0], p1[1]);
        ctx.lineTo(p2[0], p2[1]);
        ctx.lineTo(p3[0], p3[1]);
        ctx.closePath();
        ctx.strokeStyle = stroke || '';
        stroke && ctx.stroke();
        ctx.fillStyle = fill || '';
        fill && ctx.fill();
    }

    function cross(ctx, x, y, size, color, angle) {
        angle = angle || 0;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        size = size || 5;
        color = color || 'black';
        ctx.beginPath();
        ctx.moveTo(-size, 0);
        ctx.lineTo(+size, 0);
        ctx.moveTo(0, -size);
        ctx.lineTo(0, +size);
        ctx.closePath();
        ctx.strokeStyle = color;
        ctx.stroke();
        ctx.restore();
    }

    function line(ctx, p1, p2, color, alpha) {
        ctx.beginPath();
        var a = ctx.globalAlpha;
        ctx.globalAlpha = alpha || 1;
        ctx.strokeStyle = color || 'black';
        ctx.moveTo(p1[0], p1[1]);
        ctx.lineTo(p2[0], p2[1]);
        ctx.stroke();
        ctx.closePath();
        ctx.globalAlpha = a;
    }

    function avgPoints(points) {
        var avg=[0, 0];
        avg[0] = points.reduce(function (m, v) { return m + v[0]; }, 0) / points.length;
        avg[1] = points.reduce(function (m, v) { return m + v[1]; }, 0) / points.length;
        return avg;
    }

    function isTooClose(p1, p2, d) {
        var dx = p2[0] - p1[0];
        var dy = p2[1] - p1[1];
        return ((dx * dx + dy * dy) < (d * d));
    }

    function checkSet(p, others, d) {
        var ok = true;
        others.forEach(function(o) {
            ok = ok && !isTooClose(p, o, d)
        });
        return ok;
    }

    function circumcenter(a, b, c) {
        var ax = a[0];
        var ay = a[1];
        var bx = b[0];
        var by = b[1];
        var cx = c[0];
        var cy = c[1];

        // midpoints
        var midAB = avgPoints([a, b]);
        var midAC = avgPoints([a, c]);

        // slopes
        var mAB = (by - ay) / (bx - ax);
        var mAC = (cy - ay) / (cx - ax);
        // invert for perpendicular
        mAB = -1/mAB;
        mAC = -1/mAC;

        // offsets
        var bAB = midAB[1] - mAB * midAB[0];
        var bAC = midAC[1] - mAC * midAC[0];

        var CCx;
        var CCy;

        // algebra!
        CCx = (bAC - bAB) / (mAB - mAC);
        CCy = mAB * CCx + bAB;

        var dx = CCx - ax;
        var dy = CCy - ay;
        var r = Math.sqrt(dx * dx + dy * dy);

        return {x: CCx, y: CCy, r: r};
    }

    function drawEdges(ctx, p1, p2, p3) {
        ctx.globalAlpha = 0.2;
        ctx.globalCompositeOperation = 'multiply';
        ctx.strokeWidth = 1;
        
        ctx.beginPath();
        ctx.moveTo(p1[0], p1[1]);
        ctx.strokeStyle = '#f00';
        ctx.lineTo(p2[0], p2[1]);
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.moveTo(p2[0], p2[1]);
        ctx.strokeStyle = '#00f';
        ctx.lineTo(p3[0], p3[1]);
        ctx.stroke();
        ctx.closePath();

        ctx.beginPath();
        ctx.strokeStyle = '#0a0';
        ctx.moveTo(p3[0], p3[1]);
        ctx.lineTo(p1[0], p1[1]);
        ctx.stroke();
        ctx.closePath();
    }



    function scatter(selector, spacing, pointSize, decorate) {
        var el = document.querySelector(selector);
        var ctx = el.getContext('2d');

        var gridSize = spacing * 1.5;
        var R = spacing/2;
        var cellR = gridSize - R;
        var w = el.width;
        var h = el.height;

        var hexW = 2 * 0.8660 * gridSize;
        var hexH = 1.5 * gridSize;

        var cols = Math.ceil(w / hexW) + 1;
        var rows = Math.ceil(h / hexH) + 1;
        var row; // current row in loops
        var col; // current col in loops

        ctx.fillStyle = 'black';
        ctx.strokeStyle = '#ccc';

        var layout = getTiledLayout(w, h, gridSize);
        // [rowsâ€¦][cols]
        var points = [];
        var topTriangles = [];

        var renderCount = rows * cols; // track points and repacking.

        // placement vars
        var cc; // circumcenter from points
        var packed = []; // coords from cc
        var tricc; // circumcenter from packed top triangles
        var tripacked; // coords from tricc

        if (decorate) {
            ctx.globalCompositeOperation = 'multiply';
        }

        var start = new Date().getTime();
        console.log('start drawing');

        ctx.font = '12px sans-serif';

        // Main points
        layout.forEach(function(p, i) {
            var x = p[0];
            var y = p[1];

            row = Math.floor(i / cols);

            var fillColor = row % 2 ? '#fdd' : '#def';

            if (decorate) {
                ctx.globalCompositeOperation = 'screen';
                ctx.globalAlpha = 0.33;

                // the exclusion ring
                circle(ctx, x, y, gridSize, '#f99', fillColor);
                ctx.globalCompositeOperation = 'normal';
                circle(ctx, x, y, cellR, '#f99', '#fff');
                ctx.globalCompositeOperation = 'multiply';

                ctx.globalAlpha = 1;
            }

            // the point
            var a = randomInRange(0, TWOPI);
            var v = randomInRange(0, cellR - pointSize);
            var px = x + v * Math.cos(a);
            var py = y + v * Math.sin(a);
            circle(ctx, px, py, pointSize, null, '#000');
            points.push([px, py]);

            // show point exclusion zone
            if (decorate) {
                circle(ctx, px, py, R, '#ace', '#fff');

            }
        });

        // Pack points in top triangles
        var grid = points;
        for (var i = 0 ; i < grid.length - cols ; i++) {            
            row = Math.floor(i / cols);

            if (i % cols >= cols - 1) {
                continue;
            }

            var nextRowColOffset = (row % 2) ? 0 : 1;

            // top triangles: get points from grid
            var p1 = grid[i];
            var p2 = grid[i + 1];
            var p3 = grid[i + cols +  nextRowColOffset];

            cc = circumcenter(p1, p2, p3);
            packed = [cc.x, cc.y];
            topTriangles[i] = (packed);

            ctx.globalAlpha = 1;

            if (cc.r > spacing) {
                circle(ctx, packed[0], packed[1], pointSize, null, '#69f');
                decorate && circle(ctx, packed[0], packed[1], R, '#cf9');
                renderCount++;
            } else {
                decorate && circle(ctx, packed[0], packed[1], pointSize, '#faa', null);
                decorate && circle(ctx, packed[0], packed[1], R, '#fdc', null);
            }

            if (decorate) {
                ctx.globalAlpha = 0.2;
                triangle(ctx, p1, p2, p3, '#fff', '#ffc');
            }
            
        }

        // now pack points in bottom triangles
        //var grid = points;
        for (var i = cols ; i < grid.length - 1 ; i++) {
            // bottom triangles

            row = Math.floor(i / cols);

            var odd = row % 2; // odd or even row
            var step = i % cols; // step within a row
            
            if (step >= cols - 1) {
                continue;
            }

            var colOffset = odd ? 0 : 1;

            var p1 = grid[i];
            var p2 = grid[i + 1];
            var p3 = grid[i - cols + colOffset];

            cc = circumcenter(p1, p2, p3);
            packed = [cc.x, cc.y];

            ctx.globalAlpha = 1;

            var pp1;
            var pp2;
            var pp3;

            if (odd) {
                pp1 = topTriangles[i - cols - 1 ];
                pp2 = topTriangles[i - cols - 0 ];
                pp3 = topTriangles[i];
            } else {
                pp1 = topTriangles[i - cols + 0 ];
                pp2 = topTriangles[i - cols + 1 ];
                pp3 = topTriangles[i];
            }

            var hasTriangles = pp1 && pp2 && pp3;

            if (hasTriangles) {
                tricc = circumcenter(pp1, pp2, pp3);
                tripacked = [tricc.x, tricc.y];
            }

            ctx.globalAlpha = 1;

            // check circumcenter against its component points
            var ccOK = (cc.r > spacing);
            // now check against the neighboring packed points
            if (ccOK && hasTriangles) {
                ccOK = checkSet(packed, [pp1, pp2, pp3], spacing);
            }

            var tripOK = false;
            if (tricc && !ccOK) {
                tripOK = (tricc.r > spacing);

                if (tripOK) {
                    tripOK = checkSet(tripacked, [p1,p2,p3], spacing);
                }
            }


            if (ccOK) {
                //console.log('packed');
                circle(ctx, packed[0], packed[1], pointSize, null, '#900');
                renderCount++;
                decorate && circle(ctx, packed[0], packed[1], R, '#cf9', null);
            } else {
                decorate && circle(ctx, packed[0], packed[1], pointSize, '#faa', '#fff');
                decorate && circle(ctx, packed[0], packed[1], R, '#fdc', '#fff');
            }

            if (tricc && !ccOK) {
                if (tripOK) {
                    //console.log('tripacked');
                    circle(ctx, tripacked[0], tripacked[1], pointSize, null, '#900');
                    renderCount++;
                    decorate && circle(ctx, tripacked[0], tripacked[1], R, '#cf9', null);
                } else {
                    decorate && cross(ctx, tripacked[0], tripacked[1], pointSize, '#faa', '#fff');
                    decorate && circle(ctx, tripacked[0], tripacked[1], R, '#fdc', '#fff');
                }
            }

            if (!ccOK && !tripOK && tricc && hasTriangles) {
                packed = avgPoints([packed, tripacked]);
                ccOK = checkSet(packed, [p1, p2, p3, pp1, pp2, pp3], spacing);
                if (ccOK) {
                    //console.log('avg packed');
                    circle(ctx, packed[0], packed[1], pointSize, null, '#900');
                    renderCount++;
                    decorate && circle(ctx, packed[0], packed[1], R, '#cf9', null);
                } else {
                    decorate && circle(ctx, packed[0], packed[1], pointSize, '#faa', '#fff');
                    decorate && circle(ctx, packed[0], packed[1], R, '#fdc', '#fff');
                }

            }

            if (decorate) {
                ctx.globalAlpha = 0.1;
                triangle(ctx, p1, p2, p3, '#fff', '#09f');
            }            
        }

        ctx.globalAlpha = 1;

        console.log('Rendered ', renderCount, 'points in', new Date().getTime() - start, 'ms');
    }


    scatter('#large', randomInRange(30, 50), randomInRange(3, 4), true);
    scatter('#small', 10, 2);
    var m = randomInRange(15, 40);
    scatter('#medium', m, m/randomInRange(10,15));





</script>
</body>
</html>